<!DOCTYPE html>
<html>
  <head>
    <link id="page_style" rel="stylesheet" type="text/css" href="css/default.css">
  </head>
  <body class="dialog_body">
    <div class="container">
    <form> 
      <fieldset> 
        <legend></legend> 
      </fieldset> 
    <div class="submit_buttons">
      <button type="button"
              onClick="ok();"
              id="ok_button"
              data-i18n="[title]iem.prop.ok_tt">
        <span data-i18n="iem.prop.ok"></span>
      </button>
      <button type="button"
              onClick="apply();"
              id="apply_button"
              data-i18n="[title]iem.prop.apply_tt">
        <span data-i18n="iem.prop.apply"></span>
      </button>
      <button type="button"
              onClick="cancel(true);"
              data-i18n="[title]iem.prop.cancel_tt">
        <span data-i18n="iem.prop.cancel"></span>
      </button>
    </div>
  </form> 
  </div>      
  <script>
"use strict";
var gui = require("nw.gui");
var pdgui = require("./pdgui.js");

// For translations
var l = pdgui.get_local_string;

pdgui.skin.apply(window);

var pd_object_callback;
var old_properties; // Original values in case the user wants to cancel changes
var new_properties; // Updated values

// Grab focus for one of the buttons
function focus_button(id) {
    document.getElementById(id).focus();
}

function send_props_to_pd(attr_array) {
    var values = [];
    // Todo: parse symbols the same way we do for iemguis before
    // sending them back to Pd. This might require some fanagling on
    // the pd side of things...
    attr_array.forEach(function(elem) {
        values.push(elem.value);
    });
    pdgui.pdsend(pd_object_callback, "dialog", values.join(" "));
}

function apply() {
    focus_button("apply_button");
    send_props_to_pd(new_properties); 
}

function cancel() {
    send_props_to_pd(old_properties);
    pdgui.pdsend(pd_object_callback, "cancel");
}

function ok() {
    // Focus button so that the "change" event triggers
    // for the form before sending values to Pd
    focus_button("ok_button");
    send_props_to_pd(new_properties);
    pdgui.pdsend(pd_object_callback, "cancel");
}

// turn a ["name", value, etc.] array
// into an array of objects where each object contains
// name: name for the input element
// type: type of element (number, string, toggle)
// label: string label (basically the name with underscores turned to spaces)
// value: a value for the input
function parse_attrs(attrs) {
    var ret = [],
        elem,
        gate = false;
    attrs.forEach(function(attr, i) {
        if (i % 3 === 0) {
            elem = gate ? elem : {};
            gate = attr === "enum";
            elem.type = attr;
        } else if (i % 3 === 1) {
            elem.name = attr;
            elem.label = attr.replace("_", " ");
        } else {
            if (elem.type === "enum") {
                if (elem.options) {
                    elem.options.push(attr);
                } else {
                    elem.options = [attr];
                }
            } else {
                elem.value = attr;
            }
            // now push the object onto the array
            if (elem.type !== "enum") {
                elem.type = elem.type === "enum_index" ? "enum" : elem.type;
                ret.push(elem);
            }
        }
    });
    return ret;
}

// This gets called from the nw_create_window function in index.html
// It provides us with our window id from the C side.  Once we have it
// we can create the menu and register event callbacks
function register_window_id(gfxstub, args) {
    var external_name = args.name,
        array_of_objects;
    pd_object_callback = gfxstub;
    array_of_objects = parse_attrs(args.attributes);
    // Store our array for later use
    new_properties = array_of_objects;
    // Also make a copy in the case that the user cancels this dialog
    old_properties = JSON.parse(JSON.stringify(array_of_objects));    

    add_events(gfxstub);
    // not sure that we need this for properties windows
    //pdgui.canvas_map(gfxstub);
    translate_form();

    build_form(external_name, array_of_objects);
    // We don't turn on rendering of the "container" div until
    // We've finished displaying all the spans and populating the
    // labels and form elements.  That makes it more efficient and
    // snappier, at least on older machines.
    document.getElementsByClassName("container")[0]
        .style.setProperty("display", "inline");
}

// Stop-gap translator
function translate_form() {
    var elements = document.querySelectorAll("[data-i18n]"),
        data,
        i;
    for (i = 0; i < elements.length; i++) {
        data = elements[i].dataset.i18n;
        if (data.slice(0, 7) === "[title]") {
            elements[i].title = l(data.slice(7));
        } else {
            elements[i].textContent = l(data);
        }
    }
}

function get_input_type(t) {
    return t === "symbol" ? "text" :
           t === "int" ? "text" :
           t === "float" ? "text" :
           t === "color" ? "color" :
           t === "enum" ? "select" :
           t === "toggle" ? "checkbox":
                            "text";
}

function build_form(external_name, array_of_objects) {
    var fieldset = document.querySelector("fieldset");
    document.querySelector("legend").textContent = external_name;
    array_of_objects.forEach(function(ob) {
        var elem,
            label,
            type = get_input_type(ob.type);
        if (type === "select") {
            elem = document.createElement("select");
            ob.options.forEach(function(e) {
                var option = document.createElement("option");
                option.textContent = e;
                elem.appendChild(option);
            });
            elem.selectedIndex = ob.value;
            elem.onchange = function() {
                ob.value = elem.selectedIndex;
            }
        } else if (type === "checkbox") {
            elem = document.createElement("input");
            elem.type = "checkbox";
            elem.checked = ob.value !== 0;
            elem.onchange = function() {
                ob.value = elem.checked ? 1 : 0;
            };
        } else {
            elem = document.createElement("input");
            elem.type = type;
            elem.value = ob.value;
            elem.onchange = function() {
                ob.value = elem.value;
            }
        }
        label = document.createElement("label");
        label.textContent = ob.label;
        label.appendChild(elem);
        fieldset.appendChild(label);
        // stop-gap until we make this prettier through css: insert a break
        fieldset.appendChild(document.createElement("br"));
    });
}

function add_events(name) {
    // closing the Window
    gui.Window.get().on("close", function () {
        // this needs to do whatever the "cancel" button does
        cancel();
    });
    pdgui.dialog_bindings(name);
}
  </script>
  </body>
</html>
